#!/usr/bin/env python3
import argparse
import json
import signal
import subprocess
import sys
from contextlib import ExitStack
from dataclasses import dataclass
from pathlib import Path


@dataclass
class Config:
    tables: list[str]


def main(config: Config, transport_dir: Path, target: str, yes: bool) -> int:
    if not transport_dir.exists():
        print(f"ERROR: directory {transport_dir} does not exist", file=sys.stderr)
        return 1

    geopackage_paths = [
        path
        for path in transport_dir.glob("*/BDTOPO/1_DONNEES_LIVRAISON_*/*/TRANSPORT/*")
        if path.stem in config.tables
    ]

    if not geopackage_paths:
        print("WARNING: no geopackages found", file=sys.stderr)
        return 2

    with ExitStack() as exit_stack:
        if target.startswith(("postgresql://", "postgres://")):
            database_url = target
        else:
            app = target

            print(f"===> Opening DB tunnel to app {app}...")

            tunnel_proc = exit_stack.enter_context(
                subprocess.Popen(
                    [
                        "./tools/scalingodbtunnel",
                        app,
                        "--env-var",
                        "BDTOPO_DATABASE_URL",
                    ],
                    stdout=subprocess.PIPE,
                )
            )

            def _close_tunnel():
                print("---> Stopping tunnel...")
                tunnel_proc.send_signal(signal.SIGINT)
                tunnel_proc.wait()

            exit_stack.callback(_close_tunnel)

            database_url = tunnel_proc.stdout.readline().decode()

            if not database_url:
                print(
                    "ERROR: failed to open DB tunnel, see output above",
                    file=sys.stderr,
                )
                return 1

            print("---> Tunnel open.")

            # TODO remove
            database_url = "postgresql://dialog:dialog@localhost:5432/dialog_bdtopo"

        print("===> Will import into")
        print(database_url)

        if not yes and input("------> Proceed? (y/N) ") != "y":
            return 1

        print("===> Importing BD TOPO content...")

        temp_tables_to_drop = set()

        try:
            tables_to_rename = {}

            for path in geopackage_paths:
                # Import into temporary tables, we'll rename everything at once if
                # all imports were successful, otherwise we'll drop all temp tables.

                target_table = path.stem  # e.g. voie_nommee
                temp_table = f"{target_table}_temp"  # e.g. voie_nommee_temp
                print(f"------> Import into {temp_table}: {path}")

                temp_tables_to_drop.add(temp_table)

                result = subprocess.run(
                    [
                        # See general ogr2ogr options here:
                        # https://gdal.org/programs/ogr2ogr.html
                        "ogr2ogr",
                        "-progress",
                        # Append to existing table (for subsequent runs of this command)
                        "-append",
                        # Import into the temporary table
                        "-nln",  # nln = New layer name
                        temp_table,
                        # Use explicit primary key column name for renaming
                        "-lco",
                        "FID=fid",
                        # Setup connection to the PostgreSQL database
                        # See specific PostgreSQL options here:
                        # https://gdal.org/drivers/vector/pg.html
                        "-f",
                        "PostgreSQL",
                        f"PG:{database_url}",
                        # Enable slightly faster ingestion
                        # https://gdal.org/drivers/vector/pg.html#config-PG_USE_COPY
                        "--config",
                        "PG_USE_COPY",
                        "YES",
                        # Path to source geopackage
                        str(path),
                    ],
                )

                if result.returncode:
                    print(
                        "ERROR: ogr2ogr command failed, see output above",
                        file=sys.stderr,
                    )
                    return 1

                tables_to_rename[temp_table] = target_table

            print("------> Import successful!")

            print("------> Renaming tables...")

            # Now we replace all existing tables with their temporary equivalent
            # where the data has just been successfully imported.

            statements = []

            for temp_table, target_table in tables_to_rename.items():
                statements += [
                    # Need to rename indices and sequences explicitly because they are not renamed automatically when tables are renamed.
                    f"""
                    DO $$ BEGIN
                        IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = '{target_table}') THEN
                            EXECUTE '
                                ALTER TABLE {target_table} RENAME TO {target_table}_old;
                                ALTER SEQUENCE {target_table}_fid_seq RENAME TO {target_table}_old_fid_seq;
                                ALTER INDEX {target_table}_pkey RENAME TO {target_table}_old_pkey;
                                ALTER INDEX {target_table}_geometrie_geom_idx RENAME TO {target_table}_old_geometrie_geom_idx;
                            ';
                        END IF;
                    END$$;""",
                    f"ALTER TABLE {temp_table} RENAME TO {target_table};",
                    f"ALTER SEQUENCE {temp_table}_fid_seq RENAME TO {target_table}_fid_seq;",
                    f"ALTER INDEX {temp_table}_pkey RENAME TO {target_table}_pkey;",
                    f"ALTER INDEX {temp_table}_geometrie_geom_idx RENAME TO {target_table}_geometrie_geom_idx;",
                    f"DROP TABLE IF EXISTS {target_table}_old;",
                ]

            # Wrap in a transaction to make sure we rename everything, or do nothing.
            sql = "".join(["BEGIN;", *statements, "COMMIT;"])

            # If an error occurs here, the database will rollback the transaction,
            # undoing any RENAME's or DROP TABLE's, and we'll proceed to cleaning up
            # temporary tables through the 'finally' clause below.
            result = subprocess.run(["psql", database_url, "-c", sql])
            result.check_returncode()

            for temp_table in tables_to_rename:
                temp_tables_to_drop.remove(temp_table)  # It was renamed.

            print("------> Tables successfully renamed")
        except KeyboardInterrupt:
            # Stop everything, we'll proceed to clean up in the 'finally' block.
            return 3
        finally:
            if temp_tables_to_drop:
                print("---> Cleaning up temporary tables...")

                for table in temp_tables_to_drop:
                    sql = f"DROP TABLE IF EXISTS {table};"
                    print(f"------> Executing: {sql}")

                    result = subprocess.run(["psql", database_url, "-c", sql])

                    if result.returncode:
                        print(
                            "WARNING: there was an issue while dropping "
                            f"temporary table {table}, see output above",
                            file=sys.stderr,
                        )

    return 0


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "transport_dir",
        type=Path,
        help="Path to directory of BD TOPO Transport Theme data",
    )
    parser.add_argument(
        "target", help="Name of Scalingo app, or a PostgreSQL database URL"
    )
    parser.add_argument(
        "--prod", action="store_true", help="Required if targetting 'dialog' app"
    )
    parser.add_argument("-y", "--yes", action="store_true", help="Accept all prompts")
    parser.add_argument(
        "-c",
        "--config",
        type=Path,
        default=Path(__file__).parent / "bdtopo_update.config.json",
    )
    args = parser.parse_args()

    if args.target == "dialog" and not args.prod:
        print(
            "ERROR: please pass --prod when targetting the production environment",
            file=sys.stderr,
        )
        sys.exit(1)

    config = Config(**json.loads(args.config.read_text()))

    sys.exit(
        main(
            config,
            transport_dir=args.transport_dir,
            target=args.target,
            yes=args.yes,
        )
    )
